# -*- coding: utf-8 -*-
"""NLP_HMM_Ceaser test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13GzkMFyYNOTgzvrzu9XTUsKpSp9hOjeE
"""

with open('test.h', 'r') as file:
    data = file.read().replace('\n', '')

print(data, type(data))
# Removing Puncutations
punc = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
for i in data:
  if i in punc: 
        data = data.replace(i, "") 

print(data)

data = data.split(" "*13)
print(data)

data.pop(0)
print(data)

print(data[0].index('s'))
print(data[0].index('N'))

#Getting the plaintext as string elements of a list
a = data[0]
a = a.split(" "*12)
print(a)

#Getting the ciphertext as string elements of a list
b = data[2]
b = b.split(" "*12)
print(b)

a.append(data[1][:31])
b.append(data[3])
print(a)
print(b)

#Generating plaintext ciphertext pairs for 80 percent of data
table =[]
for i,j in zip(a[:48],b[:48]):
  pt = i.split()
  ct = j.split()
  for q,s in zip(pt, ct):
    temp = []
    temp.append(q)
    temp.append(s)
    table.append(temp)
print(table)



print(table)

"""Generating Transition Matrix"""

import pandas as pd

rows = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
Transition_matrix = pd.DataFrame(0,columns = rows, index = rows)
another = Transition_matrix = pd.DataFrame(0,columns = rows, index = rows)
t_cipher = pd.DataFrame(0,columns = rows, index = rows)
print(Transition_matrix)

for i in a[:48]:
 #print(i)
 rem_space = "".join(i.split())
 for j in range(len(rem_space)-1):
  Transition_matrix[rem_space[j+1].lower()][rem_space[j].lower()] = Transition_matrix[rem_space[j+1].lower()][rem_space[j].lower()]+1
print(Transition_matrix)

#Transition_matrix contains lettter wise bigram freq of plaintext
#t_cipher contains lettter wise bigram freq of ciphertext
for i in table:
  for j in range(len(i[1])-1):
    t_cipher[i[1][j+1].lower()][i[1][j].lower()] = t_cipher[i[1][j+1].lower()][i[1][j].lower()] + 1 
print(t_cipher)

t_prob = pd.DataFrame(0.0, columns = rows, index = rows)
#Finding Probabilities
for i in Transition_matrix.index:
  addition = sum(Transition_matrix.loc[i])
  #print(addition)
  for j in range(len(Transition_matrix.loc[i])):
   # print(j)
    t_prob[chr(j+97)][i] = Transition_matrix[chr(j+97)][i]/addition
print(t_prob)

print(table)

#Calculating occurrences of plaintext ciphertext pair
plain_cipher_freq = pd.DataFrame(0, columns = rows, index = rows)
for pair in table:
  for i, j in zip(pair[0], pair[1]):
    plain_cipher_freq[j.lower()][i.lower()] = plain_cipher_freq[j.lower()][i.lower()] + 1

print(plain_cipher_freq)

#Calculating probability of plaintext ciphertext pair
Emission_matrix = pd.DataFrame(0.0, columns = rows, index = rows)
for i in plain_cipher_freq.index:
  addition = sum(plain_cipher_freq.loc[i])
  for j in range(len(plain_cipher_freq.loc[i])):
    Emission_matrix[chr(j+97)][i] = plain_cipher_freq[chr(j+97)][i]/addition
print(Emission_matrix)

#Initial prob 
pi = pd.DataFrame(0.0, columns = rows, index =[0])
for i in a[:48]:
  pi[i[0].lower()][0] =  pi[i[0].lower()][0] +1.0

for i in pi:
  pi[i][0] = pi[i][0]/len(a)

def find_probable(alpha):
  plain_text =""
  for i in range(len(list(alpha.columns))):
    plain_text = plain_text + chr(list(alpha[i]).index(max(alpha[i]))+97)
  return plain_text

def viterbi(obs, pi, A, B, rows):
  obs = obs.lower()
  seq = list("".join(obs.split()))
  alpha = pd.DataFrame(0.0, columns = range(len(seq)), index = rows)
  for i in rows:
    alpha[0][i] = pi[i][0] * B[seq[0]][i]
  #print(alpha)
  for i in range(1, len(seq)):
    for j in rows:
      sum = 0.0
      for k in rows:
        sum += alpha[i-1][k] * A[j][k]* B[seq[i]][j]
      alpha[i][j] = sum
  return find_probable(alpha)

count = 0
total_count = 0
#Running on test data
for i in range(45, 60):
  plain = viterbi(b[i], pi, t_prob, Emission_matrix, rows)
  total_count = total_count + len(plain)
  for m,n in zip(plain, "".join(a[i].lower().split())):
      if m==n:
        count = count+1
  print(plain, a[i])
print("Accuracy = ",count/total_count)
print(count, total_count)

Emission_matrix

